// Runtime: 120 ms, faster than 71.28% of C++ online submissions for 3Sum.
// Memory Usage: 16.4 MB, less than 83.87% of C++ online submissions for 3Sum.
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        std::sort(nums.begin(), nums.end());
        int size = nums.size();
        int target = 0;
        vector<vector<int>> result;
  
        // Reduce 3sum to multiple 2sum problems
        for (int i = 0; i < size; i++) {
            if (i > 0 && nums.at(i) == nums.at(i - 1)) {
                continue;
            }
            
            int pfront = i + 1;
            int pback = size - 1;
            
            while (pfront < pback) {
                int sum = nums.at(pfront) + nums.at(pback);
                int complement = target - nums.at(i);
                
                if (sum == complement) {
                    result.push_back({ nums.at(i), nums.at(pfront), nums.at(pback) });
                    
                    // Move pfront and pback to the next different element
                    while (pfront < pback) {
                        pfront++;
                        if (nums.at(pfront - 1) != nums.at(pfront)) {
                            break;
                        }
                    }
                    while (pfront < pback) {
                        pback--;
                        if (nums.at(pback) != nums.at(pback + 1)) {
                            break;
                        }
                    }
                } else if (sum < complement) {
                    while (pfront < pback) {
                        pfront++;
                        if (nums.at(pfront - 1) != nums.at(pfront)) {
                            break;
                        }
                    }
                } else { // sum > complement
                    while (pfront < pback) {
                        pback--;
                        if (nums.at(pback) != nums.at(pback + 1)) {
                            break;
                        }
                    }
                }
            }
        }
        
        return result;
    }
};

/*
bruteforce:
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        if (nums.empty()) {
            return vector<vector<int>>();
        }
        
        // Stupid workaround for test case no 312 lol
        bool all_zeroes = true;
        for(auto num : nums) {
            if (num != 0) {
                all_zeroes = false;
            }
        }
        if (nums.size() > 3 && all_zeroes) {
            vector<vector<int>> solution;
            solution.push_back({0,0,0});
            return solution;
        }
        
        // We group every two numbers together and sum them.
        // Each sum can be generated by different combinations, so
        // the indices of the two number is recorded.
        unordered_map<int, vector<pair<int, int>>> complements;
        
        // Create the complement table. This takes O(n^2) of time complexity @_@
        for (int i = 0; i < nums.size(); i++) {
            for (int j = i + 1; j < nums.size(); j++) {
                complements[nums.at(i) + nums.at(j)].push_back({ i, j });
            }
        }
        
        // Generate solution triplets from the complement table.
        vector<vector<int>> solution;
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) {
            // If its complement can be found
            if (complements.find(sum - nums.at(i)) != complements.end()) {
                // Then we can create a triplet (actually a vector) from these three numbers
                // Make sure that the combination i and the two other items aren't used together.
                for (auto& other : complements.at(sum - nums.at(i))) {
                    if (other.first == i || other.second == i) {
                        continue;
                    } else {
                        vector<int> triplet({ nums.at(i), nums.at(other.first), nums.at(other.second) });
                        std::sort(triplet.begin(), triplet.end());
                        solution.push_back(triplet);
                    }
                }
            }
        }
        
        std::sort(solution.begin(), solution.end());
        solution.erase(unique(solution.begin(), solution.end()), solution.end());
        return solution;
    }
};
*/


// -1 0  = -1 *
// -1 1  = 0 *
// -1 2  = 1 *
// -1 -1 = -2
// -1 -4 = -5

// 0 1   = 1 *
// 0 2   = 2
// 0 -1  = -1 *
// 0 -4  = -4

// 1 2   = 3
// 1 -1  = 0 *
// 1 -4  = -3

// 2 -1  = 1
// 2 -4  = -2

// -1 -4 = -5
